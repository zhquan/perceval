# -*- coding: utf-8 -*-
#
# Copyright (C) 2015-2019 Bitergia
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#     Quan Zhou <quan@bitergia.com>
#


import json
import logging

import requests

from grimoirelab_toolkit.datetime import (datetime_to_utc,
                                          datetime_utcnow,
                                          str_to_datetime)
from grimoirelab_toolkit.uris import urijoin

from ...backend import (Backend,
                        BackendCommand,
                        BackendCommandArgumentParser)
from ...client import HttpClient, RateLimitHandler
from ...errors import RepositoryError
from ...utils import DEFAULT_DATETIME


logger = logging.getLogger(__name__)

CATEGORY_REVIEW = "review"
MAX_REVIEWS = 1
SLEEP_TIME = 30
GERRIT_AUTH_SUFFIX = "/a"
GERRIT_MAGIC_JSON_PREFIX = ")]}\'\n"
DEFAULT_HEADERS = {'Accept': 'application/json'}


class GerritREST(Backend):
    version = '0.0.1'

    CATEGORIES = [CATEGORY_REVIEW]

    def __init__(self, url, user, password,
                 max_reviews=MAX_REVIEWS, archive=None,
                 sleep_time=SLEEP_TIME):
        origin = url

        super().__init__(origin, archive=archive)
        self.url = url
        self.max_reviews = max_reviews
        self.user = user
        self.password = password
        self.sleep_time = sleep_time
        self.client = None

    def fetch(self, category=CATEGORY_REVIEW, from_date=DEFAULT_DATETIME):
        if not from_date:
            from_date = DEFAULT_DATETIME

        from_date = datetime_to_utc(from_date)

        kwargs = {'from_date': from_date}
        items = super().fetch(category, **kwargs)

        return items

    def fetch_items(self, category, **kwargs):
        """Fetch the messages.

        :param category: the category of items to fetch
        :param kwargs: backend arguments

        :returns: a generator of items
        """
        from_date = kwargs['from_date']

        more_reviews = True
        while more_reviews:
            raw_reviews = self.client.reviews(from_date=from_date)
            reviews = json.loads(raw_reviews)
            for review in reviews:
                review_number = review['_number']
                print(review['updated'])
                # review['commits_data'] = self.__get_commits(review_number)
                # review['revisions_data'] = self.__get_revisions(review_number)

                yield review

            from_date = str_to_datetime(review['updated'])

            if not reviews:
                more_reviews = False

    @classmethod
    def has_archiving(cls):
        """Returns whether it supports archiving items on the fetch process.

        :returns: this backend supports items archive
        """
        return True

    @classmethod
    def has_resuming(cls):
        """Returns whether it supports to resume the fetch process.

        :returns: this backend does not support items resuming
        """
        return False

    @staticmethod
    def metadata_id(item):
        """Extracts the identifier from a Gerrit item."""

        return str(item['_number'])

    @staticmethod
    def metadata_updated_on(item):
        """Extracts and converts the update time from a Gerrit item.

        The timestamp is extracted from 'lastUpdated' field. This date is
        a UNIX timestamp but needs to be converted to a float value.

        :param item: item generated by the backend

        :returns: a UNIX timestamp
        """
        ts = item['updated']
        ts = str_to_datetime(ts)

        return ts.timestamp()

    @staticmethod
    def metadata_category(item):
        """Extracts the category from a Gerrit item.

        This backend only generates one type of item which is
        'review'.
        """
        return CATEGORY_REVIEW

    def _init_client(self, from_archive=False):
        """Init client"""

        return GerritRESTClient(self.user, self.password, self.url,
                                self.sleep_time, self.max_reviews,
                                self.archive, from_archive)


class GerritRESTClient(HttpClient):

    def __init__(self, user=None, password=None, url=None,
                 sleep_time=SLEEP_TIME, max_reviews=MAX_REVIEWS,
                 archive=None, from_archive=False):
        base_url = urijoin(url, 'r', 'a')
        super().__init__(base_url, archive=archive, from_archive=from_archive)
        self.user = user
        self.password = password

        self.session.auth = (self.user, self.password)

        self.sleep_time = sleep_time
        self.max_reviews = max_reviews

    def reviews(self, from_date=DEFAULT_DATETIME):
        before_date = ""
        payload = {
            'n': MAX_REVIEWS
        }
        if from_date != DEFAULT_DATETIME:
            #second = int(str(from_date.timestamp()).split('.')[0])-1
            #before_date = "-age:{}s".format(second)
            before_date = "before:{}".format(from_date.isoformat(sep=' '))

            payload = {
                'q': '{}'.format(before_date),
                'n': MAX_REVIEWS
            }
        url = urijoin(self.base_url, 'changes', '')
        r = self.fetch(url, payload=payload)
        r.raise_for_status()
        content = r.content.strip()
        if r.encoding:
            content = content.decode(r.encoding)
        if content.startswith(GERRIT_MAGIC_JSON_PREFIX):
            content = content[len(GERRIT_MAGIC_JSON_PREFIX):]

        return content

    def commits(self, number):
        payload = {
            'q': number,
            'o': 'ALL_COMMITS'
        }


class GerritRESTCommand(BackendCommand):
    """Class to run Gerrit backend from the command line."""

    BACKEND = GerritREST

    @classmethod
    def setup_cmd_parser(cls):
        """Returns the Gerrit argument parser."""

        parser = BackendCommandArgumentParser(cls.BACKEND,
                                              from_date=True,
                                              basic_auth=True,
                                              archive=True)

        # Gerrit options
        group = parser.parser.add_argument_group('Gerrit arguments')
        group.add_argument('--max-reviews', dest='max_reviews',
                           type=int, default=MAX_REVIEWS,
                           help="Max number of reviews per ssh query.")
        # Required arguments
        parser.parser.add_argument('url',
                                   help="Hostname of the Gerrit server")

        return parser
